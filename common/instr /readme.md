# Новшества С++

Автор лонгрида: Максим Бакиров
- В C++ разработке с 2017 года
- С 2019 года работает в команде разработки Яндекс Браузера

Цели занятия:
- Разберём основные новшества 11, 14, 17 стандартов
- Увидим, что C++ может быть красивым и понятным
- Познакомимся с мощью современного C++

## Стандарт языка С++

### Откуда берутся стандарты
Существует Комитет ISO по стандартизации языка C++:
- создает новые версии языка
- утверждает международные стандарты

Первый стандарт C++ вышел в 1985 г.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/instr/1.png)

Современный C++ начинается с 2011 г. После версии C++11 новые стандарты выходили каждые 3 года.

## Нововведения C++11

- Ключевое слово auto
- Range based for
- Лямбда-функции
- Спецификаторы override и final
- Семантика перемещения
- Умные указатели
- Кортежи
- Constexpr

## Ключевое слово auto

Ключевое слово «auto» в C++11 позволяет компилятору автоматически выводить тип переменной на основе значения, с которым эта переменная была проинициализирована.

В старых версиях C++, требовалось явно указывать тип переменной при ее объявлении, например:

int x = 10 (переменная x типа int, 10 - её инициализатор)

В C++11 вместо явного указания типа можно использовать ключевое слово «auto», которое позволяет компилятору самостоятельно определить тип переменной на основе её инициализатора, например:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/2.PNG)

Компилятор на основе числа 5 определил тип переменной int. 
На основе числа 4.0 - тип double, который используется для хранения чисел с плавающей точкой.
Также «auto» сработало и для объекта кастомного класса my_class ().

«Auto» будет работать и с возвращаемыми значениями функций. 
Например, функция add, которая возвращает int. В этом случае можно использовать «auto», чтобы принять этот результат:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/3.PNG)

### «Auto» удобно использовать, когда мы не знаем, какой тип будет иметь переменная.

Для примера рассмотрим функцию без определённого типа данных. 
Тип данных a и b, а также возращаемого значения будет определяться в зависимости от того, какие параметры мы туда передадим.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/5.PNG)

Если мы укажем целые числа, например, 3 и 5, то тип данных (T) будет int

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/8.PNG)

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/7.PNG)

Если мы укажем числа с точкой, например, 3.0 и 5.3, то тип данных (T) будет duble

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/9.PNG)

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/10.PNG)

### В C++11 нет возможности применения «auto» для типа отображаемых данных. 

Вместо этого, вам необходимо указать конкретные типы параметров.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/11.PNG)

Однако, уже в C++14 применение "auto" становится возможно.

### Чем полезно использование «auto»:
- Улучшает абстракцию: принуждает думать в терминах интерфейсов, а не реализаций. Мы поднимаемся на уровень выше, когда думаем не о самом объекте, а том, как его можно применить.
- Заставляет инициализировать переменные, что избавляет от ситуаций, когда в переменной лежит что-то не то.
- Безопасность и быстрота: нельзя опечататься в имени типа или случайно использовать другой, к которому есть неявное приведение.
- Стабильность: если тип функции изменится, то меньше случаев, когда код придется менять.
- Также «auto» сокращает код, часто помогает при работе с std.

Рассмотрим удобство «auto» для сокращения кода. 
Есть прототип некоторой функции:

std::map<std::string, std::vector<int>> some_func();

И каждый раз результат выполнения функции нужно будет сохранять в переменную типа:

std::map<std::string, std::vector<int>>

А можно написать короче:

auto result = some_func()

### Итак, важные особенности использования «auto»:
- Переменная «auto» должна быть проинициализирована.
- Переменная «auto» не может быть членом класса. Компилятор должен иметь информацию о типе, чтобы выделить память для объекта класса и правильно выполнять доступ к его полям и методам. Поэтому требуется явное указание типа для членов класса, а использование «auto» не допускается.
- До С++14 переменная «auto» не может быть параметром функции
- До С++11 тип «auto» не может быть возвращаемым типом функции 


## Range based for

Range-based for loop — это функциональность, введенная в C++11, которая позволяет проходить через элементы контейнера (такого как массив, вектор, list и т.д.) более простым и интуитивно понятным способом. 

Синтаксис Range for следующий:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/24.PNG)

### Рассмотрим, как работает классический способ:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/12.PNG)

У нас есть статический массив arr, который содержит в себе интовые элементы:

int arr[]{ 1,2,3,4,2,1,3 };

А также контейнер std::vector, который предоставляет динамический массив объектов одного типа (для использования std::vector, необходимо включить заголовочный файл <vector> и использовать пространство имен std).

std::vector<int> vi{ 1,2,3,4,5 };

Мы можем пройтись по элементам вектора классическим образом:

for (int i = 0; i < vi.size(); i++) {
	std::cout << vi[i] << "\t";
}

После компиляции мы распечатаем все элементы контейнера:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/13.PNG)

### Рассмотрим, как это будет работать с Range-based for

Поскольку у нас интовый вектор, то мы пишем:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/14.PNG)

Нужно запомнить синтксис:

for (int i : vi)

int i  - тип переменной i должен совпадать с типом объектов, которые содержит контейнер (в данном примере они интовые: vi{ 1,2,3,4,5 })
vi - название контейнера, по которому мы ходим

Каждый объект, который содержится в контейнере vi{ 1,2,3,4,5 } последовательно помещается в переменную i. 

То есть, мы проходимся по всему диапазону, в котором лежат элементы контейнера. 

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/15.PNG)

Это будет работать и с массивом arr:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/16.PNG)

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/17.PNG)

Итак, стандартный for можно использовать как foreach (цикл, основанный на диапазоне).

### Идеально использовать с «auto»

Например, если массив arr инициализируется числами типа double или используются объекты кастомного класса my_class (), удобно использовать «auto»:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/18.PNG)

Важно, чтобы у этого класса был перегружен оператор вывода в консоль. В языке C++ для вывода информации в консоль используется оператор вывода <<, который можно использовать с объектом типа std::cout из стандартной библиотеки iostream.

Если вы не модифицируете данные, лучшей практикой будет использование «const auto &». Так в переменной i не будет постоянно происходить копирование.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/20.PNG)

###  Range-based for не может быть использован с динамическими массивами, которые не являются контейнерами и не поддерживают итераторы

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/21.PNG)

Данный код создает массив arr типа int и инициализирует его значениями {1,2,3,4,2,1,3}.
Затем создается вектор vi типа std::vector<int> и инициализируется значениями {1,2,3,4,5}.
Затем создается указатель arr_d типа int* и выделяется динамическая память для массива размером 5 элементов. Элементы инициализируются значением 0. 

Далее, в цикле for каждое значение i массива arr_d выводится в консоль с помощью std::cout << i << "\t";. 

Однако, в цикле for возникает ошибка. Range-based for требует функцию "begin", которая не была обнаружена.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/22.PNG)

Давайте разберём, почему возникла эта ошибка.

### Методы begin, end

Это методы, которые предоставляют итератор на начало и конец контейнера. Они используются для перебора элементов контейнера в цикле for. 

Например:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/23.PNG)

Здесь мы перебираем элементы вектора с помощью итератора. 
vec.begin() возвращает итератор, указывающий на начало вектора, а vec.end() возвращает итератор, указывающий за конец вектора. Мы перемещаем итератор по вектору с помощью оператора инкремента it++ и проверяем, не достигли ли мы конца вектора с помощью условия it !=

В нашем примере выше:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/22.PNG)

int arr[]{ 1,2,3,4,2,1,3 }; У arr тип данных - int [7]
std::vector<int> vi{ 1,2,3,4,5 }; Стандартный контейнер std::vector
int* arr_d = new int[5] {0}; Здесь тип - int *. Это указатель на динамический массив. 

В данном случае, цикл for пытается перебрать значения указателя на массив int arr_d, но этот указатель не является диапазоном и не имеет функции begin, которую требует цикл for.

### Итак, особенности использования Range-based for:
- Массивы, контейнеры и коллекции должны иметь методы begin, end
- Объект итерации должен поддерживать операцию ++
- Объект итерации должен поддерживать оператор !=

## Лямбда-функции

Лямбда-функции - это анонимные функции, которые могут быть определены и использованы внутри других функций, включая глобальные функции. 
Они были введены в C++11 и стали очень популярными за свою компактность и удобство использования, особенно при работе с алгоритмами стандартной библиотеки.

Синтаксис:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/25.PNG)


[=] - Список захвата переменных, который определяет переменные из внешней области видимости, доступные внутри лямбда-функции. То есть, вы можете захватить любую переменную из той области видимости, в которой вы инициализируете данную функцию.

() - Параметры функций. Перечисляем, какие параметры будут приниматься этой функцией.

mutable - Изменяемая спецификация (необязательный параметр). Так вы говорите, что можете модифицировать переменные, которые захватили.

throw - Спецификация исключений (необязательный параметр). Мы должны явно указать, может ли функция выбросить исключения.

int - Возвращаемый тип функции (условно необязательный параметр)

 {
        //do something
        return x + y;
    }                     Тело функции
    

### Рассмотрим на простом примере:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/26.PNG)

Функция складывает два числа:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/27.PNG)

Основные составляющие:

[] - Список захвата переменных, который определяет, какие внешние переменные доступны лямбда-функции. В данном случае список пуст. Это означает, что данная лямбда-функция не захватывает никакие внешние переменные.

(auto a, auto b) - Входные параметры функции

{
        return a + b;
        }; - Тело функции

### Зачем это нужно?

Часто бывает ситуация, когда необходимо некоторую функцию передать как параметр в другую функцию. Например, в стандартную функцию std::sort для сортировки ваших классов.

Старое решение: объявить функцию где-то и передать по указателю
Минусы: загромождает код и область видимости

Новое решение: использовать лямбда-функции

### Рассмотрим пример без лямбда функции:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/29.PNG)

Есть структура exam_results, которая представляет собой дневник с оценками учеников.

Она содержит 2 поля:
std::string name; - имя студента
int score; - оценка студента

Функция `comparator` (функция сравнения) принимает два аргумента типа `exam_results` и сравнивает их по полю `score`. Если оценка первого студента (`lhs`) больше оценки второго студента (`rhs`), функция возвращает `true`, иначе `false`.

В функции `main` создается вектор `results`, содержащий несколько элементов типа `exam_results` с заданными именами и оценками.

std::vector<exam_results> results{ 
		{"Alex", 55}, {"Igor", 87}, {"Alena", 69} 

Затем вызывается функция `std::sort`, которая сортирует элементы вектора `results` с использованием компаратора `comparator`. Это означает, что элементы вектора будут отсортированы по убыванию оценок (от большей к меньшей).

Чтобы вывести результаты сортировки, можно использовать цикл `for` для прохода по элементам вектора и вывода их содержимого на экран:

for (const auto &result : results) {
   std::cout << result.name << " " << result.score << std::endl;
}

Этот кусок кода будет проходить через каждый элемент в results и выводить имя и результат на экзамене на консоль.

В результате выполнения программы, элементы вектора `results` будут отсортированы следующим образом:

1. "Igor", 87
2. "Alena", 69
3. "Alex", 55

![Image alt](  https://github.com/netology-code/cppl-homeworks/blob/main/common/30.PNG)

Минусы этого кода:

Мы зарезервировали имя `comparator`. Оно принадлежит именно этой совокупности дейстивий.
Но, что, если в следующий раз мы захотим отсортировать не по среднему баллу, а по длине имени ученика. 
Каждый раз нужно будет создавать `comparator`. Это дублирование кода и засорение пространства имён.

### Тот же пример с лямбда-функцией:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/31.PNG)


В первой части кода всё остаётся по-прежнему:

Есть структура `exam_results`, которая содержит два поля: `name` (имя студента) типа `std::string` и `score` (оценка) типа `int`.

В функции `main()` создан вектор `results`, который содержит объекты типа `exam_results`. Вектор заполняется тремя элементами: `{ "Alex", 55 }, { "Igor", 87 }, { "Alena", 69 }`.

Используется функция `std::sort`. 
Обратите внимание, мы и здесь передаём границы массива данных, который хотим сортировать: results.begin(), results.end(),

Во второй части кода прописываем лямбда-функцию, то есть инициализируем функцию прямо в вызове другой функции.

Входные параметры лямбда-функции такие же, как в предыдущем варианте кода: (const exam_results& lhs, const exam_results& rhs). Функция возвращает true, если балл студента слева больше, чем балл студента справа.

В теле функции то же действие, которое мы совершали с помощью `comparator`. Нам нужно вернуть результат сравнения двух параметров.

{
		return lhs.score > rhs.score;
		}

### Рассмотрим ещё один пример, чтобы убедиться, насколько лямда-функции полезны:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/33.PNG)

Данный код сортирует вектор строк `vs` в порядке возрастания и выводит отсортированные строки на экран.

Программа начинается с объявления и инициализации вектора строк `vs`, содержащего строки "ab", "bcae" и "cbad".

Затем вызывается функция `std::sort`, которая сортирует элементы вектора в заданном диапазоне, переданном ей в качестве аргументов. В данном случае, сортируются все элементы вектора `vs`. Функция `std::sort` использует алгоритм сортировки по умолчанию, который сортирует элементы лексикографически.

После сортировки, следующий цикл `for` перебирает каждый элемент вектора `vs` и выводит его на экран с помощью функции `std::cout`. Здесь `const auto & s` означает, что тип элемента вектора будет выводиться автоматически, а `&` означает, что элемент должен быть константной ссылкой, чтобы избежать копирования элемента в цикле.

Таким образом, результатом работы программы будет следующий вывод:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/34.PNG)

В данном примере элементы сортируются лексикографически. Но, что если нам нужно сравнить их по размеру.

Имплементируем лямбда-функцию:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/36.PNG)

Здесь используется лямбда-функция, которая сравнивает две строки по их длине. 

Если длина первой строки (lhs) больше длины второй строки (rhs), то возвращается true и происходит перестановка, чтобы отсортировать строки по убыванию их длины.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/37.PNG)

Таким образом, мы ввели нетривиальное правило сравнения и сделали это без создания новых функций.

Если мы захотим сравнить параметры ещё по каким-то принциам, то у нас не будет необходимости создавать всё новые и новые функции, засорять ими пространство.

### Захват переменных []

Список захвата определяет переменные, которые будут доступны внутри лямбда-функции. Таким образом, мы указываем, что должно попасть в функцию.

Как вы думаете, скомпилируется ли данная функция:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/99c394ff-cbe4-430b-9783-007f00f3bb84)

Нет, так как лямбда-функция ничего не знает про переменную "val". 

Для лямбда-функции работают те же правила, что и для любых других функций. Она имеет свою собственную область видимости и стек вызовов, в которых хранятся локальные переменные и аргументы функции. 
В данно примере в локальном стеке нет объекта "val"

Для того, чтобы у лямбда-функции был доступ к использованию переменной "val", мы её добавляем в список захвата.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/51567e83-d23f-4f28-a6c3-b3f4b5aa73e6)

Всё, что находится в контексте квадратных скобок [] является списком захвата. И, если мы хотим дать функции возможность использовать какую-то из переменных, мы добавляем её в квадратные скобки.

### Можно захватить все переменные из области видимости, где объявлена лямбда-функция, по ссылке [&] или значению [=].

Посмотрим, как это работает с [&]

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/4dfc7b7a-8512-4b52-878a-edf511522c7b)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/2b6499be-c0f5-4bf7-8c23-24c2b5933b12)

С [=] получим тот же результат:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/3288f8ed-a406-40b1-a42b-bf352ffb72f4)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/832bcaca-f755-465a-beae-272e421744ee)

Разница между [&] и [=] в способе захвата переменных оператором захвата при создании лямбда-функции:

1. Захват по ссылке [&]:
   - Позволяет лямбда-функции получить доступ к переменным внутри ее области видимости по ссылке.
   - Изменения, внесенные в переменные внутри лямбда-функции, будут отражаться на соответствующих переменных вне лямбда-функции.
   - Переменные, захваченные по ссылке, могут быть изменены даже после завершения работы лямбда-функции.

2. Захват по значению [=]:
   - Создает копию переменных из области видимости и передает их в лямбда-функцию.
   - Лямбда-функции работают с этими копиями, поэтому изменения внутри нее не влияют на значения исходных переменных.
   - Когда лямбда-функция завершает работу, копии переменных уничтожаются.

Таким образом, [&] позволяет лямбда-функции изменять значения переменных в области видимости, в то время как [=] передает только значения переменных и не позволяет их изменять.

### Можно часть переменных захватывать по ссылке, часть по значению

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/5dd1563d-edf1-431f-8da1-0aa1c9367850)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/36b71fd1-5b99-492d-b66a-ad4e4211e6b4)


### Здесь все также как в обычных функциях. Сколько параметров укажем при создании лямбды, столько обязаны использовать при её вызове.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/c8a4f20f-16dd-426e-a4f2-e831f9e3533d)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/78af916c-488f-4cfb-abb1-67c6bbeb78b9)


### Для того, чтобы захватить методы класса, нужно захватить this.  

Лямбда-функции могут захватывать переменные из своей окружающей области видимости, включая поля и методы класса. Однако, чтобы использовать методы класса внутри лямбда-функции, нужно передать указатель this, который представляет текущий экземпляр класса. Это позволяет лямбда-функции получить доступ к методам и полям конкретного экземпляра класса, с которым она работает.

### Спецификатор mutable

Данный спецификатор говорит о том, что внутри лямбда-функции можно изменять переменные, захваченные не по ссылке.

Рассмотрим перый пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/20cfc2b2-3813-41fc-829e-32ccf72a4785)

Код вызовет ошибку компиляции. 

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/476a9286-2fb7-4daa-b6ff-f23dba9e0b41)

Поскольку val захватывается по значению, изменения, внесенные лямбда-функцией, не отражаются на исходной переменной val. Это означает, что увеличение val внутри лямбды не изменит значение исходной переменной val.

Если мы создадим захват по ссылке:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/ea13250b-e96e-420c-bec7-8022073bb0e5)

Лямбда-функция func захватывает переменную val по ссылке (что означено символом &) и увеличивает её значение на 1.

На этот раз значение val равно 1, так как val был увеличен на один внутри func:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/85d89438-d9cc-4e1d-9c03-6830011cfba2)

Но, если мы можем менять само значение, почему мы не можем менять копию?

Для того, чтобы работать с копией мы должны прописать спецификатор mutable.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/e9788b1d-bf94-4518-a022-4bfe04921a6a)


Спецификатор mutable позволяет изменять значения переменных, захваченных лямбда-функцией по значению. Однако, важно понимать, что даже если val изменяется внутри лямбда-функции, это не влияет на исходную переменную val, определенную вне лямбда-функции.

Это связано с тем, что значение val, изменяемое внутри лямбда-функции, - это копия исходного значения val. Спецификатор mutable позволяет изменять копию, но не исходную переменную.

Таким образом, при выводе значения `val` на экран будет выведено исходное значение, равное 0.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/fa3829ab-fa76-4cd8-96d8-874a883126de)


Рассмотрим второй пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/c74314fd-b224-41e5-a89e-a9c40fe147dd)

У нас есть 2 интовые переменные: int val1 = 0, val2 = 0;
Далее мы инициализируем лямбда-функцию и кладём её в переменную func.


Лямбда-функция захватывает val1 по копии, а val2 - по ссылке.
Добавляем mutable, так как хотим модифицировать копию val1.
val++ увеличивает значение копии val на 1.
После этого val2 = val1.
Внутри функции val1 будет равен 1, val2 также будет равен 1.


После вызова функции:
val1 будет равен 0 несмотря на модмификации внутри функции;
val2 захвачен по ссылке, поэтому он будет равен 1. Мы изменили его внутри функции.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/1d745861-3bb5-497a-8759-23ed3fa85555)

## Спецификатор override

Давайте вспомним, какая функция называется виртуальной.

Виртуальная функция — это функция, которая может быть переопределена в классах-наследниках. Виртуальные функции используются для динамического связывания во время выполнения программы, что позволяет классу-наследнику определять свое поведение при вызове функции. 

Для определения виртуальной функции используется ключевое слово virtual в объявлении функции и базовом классе, а также override в наследнике.

Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/d0e18521-7d72-4dcf-b0a1-5625c88e5d95)

В данном коде создаются два класса: base (базовый класс) и derived (производный класс), который наследуется от базового класса.

В базовом классе определена виртуальная функция some_func, которая принимает один аргумент типа int и выводит его значение с сообщением "in base class".

В производном классе определена функция some_func, которая принимает один аргумент типа double и выводит его значение с сообщением "in derived class".

В функции main создается указатель obj типа base, который указывает на новый объект derived. Затем вызывается функция some_func через указатель obj. 

На экране появится "2 in base class". 

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/7d71cf61-40ab-416f-8c60-2e69f0a5a385)

Но, почему не "2 in derived class"?

Важное правило переопределения в C++ гласит, что при переопределении функции в производном классе, входные типы (аргументы) должны совпадать с входными типами (аргументами) виртуальной функции базового класса. В случае, если типы не совпадают, это может привести к непредсказуемому поведению программы.

В данном коде правило переопределения нарушено, так как функция some_func в классе derived принимает аргумент типа double, в то время как виртуальная функция some_func в классе base принимает аргумент типа int. 

На самом деле, в классе derived мы создали новую функцию (перепутав тип входного аргумента у some_func), а не переопределили функцию базового класса. 

class derived : public base {
public:
	void some_func(double val) 

В больших программах такие ошибки будет довольно сложно найти.

Решение: использовать спецификатор override. 
Когда вы пишете override, вы говорите, что эта функция уже есть в базовом классе, я её просто переопределяю. 
Но компилятор выдаст ошибку, так как данный метод не переопределяет ни одну виртуальную функцию из базового класса.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/9c5052cf-7157-4c53-8f6f-8decf9fcabc5)

## Спецификатор final

Если вы хотите, чтобы ваш метод больше не переопределялся, добавьте спецификатор final:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/231c09b6-2a63-41fd-a7cc-2bd9b983f64e)

В данном коде определены три класса: base, derived1 и derived2. 

В классе derived1 используется спецификатор final, который запрещает дальнейшее переопределение функции some_func в производных классах. Таким образом, класс derived2 не может переопределить функцию some_func из класса derived1.

Таким образом, при выполнении кода, появятся ошибки:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/cf78ad3a-5d41-41d8-a784-edf93884af10)


## Семантика перемещения

Семантика перемещения - набор правил и средств языка С++, предназначенных для перемещения объектов, время жизни которых скоро истекает, вместо их копирования.

Рассмотрим пример с кодом:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/996a13c7-6668-42af-81bd-05adaac49679)

Данный код определяет функцию swap, которая принимает две ссылки на векторы целых чисел типа std::vector<int>&. Функция меняет местами содержимое векторов, используя временный вектор tmp.

Сначала функция создает временный вектор tmp и копирует в него содержимое первого вектора lhs. Затем, функция присваивает содержимое второго вектора rhs первому вектору lhs. Наконец, функция присваивает содержимое временного вектора tmp второму вектору rhs.

Здесь произойдёт три копирования, три потенциально затратных операции.

Если передать в эту функцию большие массивы, например, по 1’000’000 элементов, то в силу особенностей реализации std::vector будет 3’000’000 лишних операций копирования.

Решением этой проблемы будет использование std::move.

Когда объект перемещается с помощью `std::move`, его состояние и ресурсы, такие как динамическая память или открытые файлы, могут быть "украдены" другим объектом, тем самым избегая лишних копирований и улучшая производительность программы.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/a4efed8d-1ed1-47ba-ae30-34a9dab28854)

В данном коде определена функция swap, которая принимает две ссылки на векторы целых чисел типа std::vector<int>&. Функция меняет местами содержимое векторов, используя функцию std::move.

Сначала функция создает временный вектор tmp и перемещает в него содержимое первого вектора lhs. Затем, функция перемещает содержимое второго вектора rhs в первый вектор lhs. Наконец, функция перемещает содержимое временного вектора tmp во второй вектор rhs.

Использование функции std::move позволяет эффективно перемещать содержимое векторов, минимизируя копирование и выделение памяти.

Таким образом, после вызова функции swap содержимое двух переданных векторов будет поменяно местами.

std::vector - это элемент, который содержит в себе указатель, поскольку он работает на динамической памяти. Вместо того, чтобы обходить все элементы std::vector мы обмениваем указатели. То есть, у tmp есть какой-то указатель, и у lhs также есть указатель. Вместо того, чтобы обходить и копировать все элементы, можно просто обменять два указателя.

В примере мы три раза обмениваем указатели:

	std::vector<int> tmp = std::move(lhs);
	lhs = std::move(rhs);
	rhs = std::move(tmp);

Далее на курсе вы изучите эту тему подробнее.

### Умные указатели

Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/74ffce75-8347-47e1-8abe-9b6dde825ef6)

Функция some_func создает динамический массив my_data из 600 элементов с помощью оператора new.

Затем она проверяет некоторое условие (переменная some_condition), и если оно выполняется, возвращает значение 1.

Если другое условие (another_condition) верно, функция вызывает функцию test_func и возвращает значение 2.

Память, выделенная для массива "my_data", освобождается с помощью оператора "delete[]".

У этого кода есть недостатки:
- Если выполнится какое-либо из условий some_condition, another condition, то выделенная память не удалится. Нужно в каждом условии писать удаление - это дублирование кода
- Если вдруг в функции test_func возникнет исключение, то опять память не удалится, возникнут утечки памяти.

Решением будет такой объект, который самостоятельно заботится о высвобождении своих ресурсов

Для этого созданы умные указатели (smart pointers). Это классы в C++, предоставляющие интерфейс и функциональность обычных указателей, но с дополнительными возможностями автоматического управления памятью.

В std введены следующие классы:

- auto_ptr старый умный указатель - не использовать! (Удалён в C++17)
- unique_ptr предоставляет уникальное владение объектом (один указатель - один объект)
- shared_ptr предоставляет совместное владение объектом (несколько указателей - один объект, например, 4 указателя на одну динамическую память)
- weak_ptr решает некоторые проблемы, которые возникают с shared_ptr

Основная цель умных указателей - предотвращение утечек памяти и ошибок освобождения памяти, которые могут возникать при использовании обычных указателей. Умные указатели автоматически освобождают выделенную память, когда объект, на который они указывают, становится недостижимым или выходит из области видимости.

### Кортежи

Кортеж - это коллекция фиксированного размера, которая позволяет хранить элементы различных типов.

Если раньше по правилам C++ массив типа int мог содержать только элементы типа int, а массив типа float - только типа float и т.д., то с появлением кортежей в стандарте C++11 появилась возможность хранить элементы различных типов в одной коллекции.

В C++ кортежи реализуются с помощью структуры `std::tuple`. 

### Синтаксис кортежа в C++ следующий:

- Вариант 1: Создание кортежа через конструктор

std::tuple<std::string, int, char, double> test(“str”, 4, ‘a’, 3.0)

- Вариант 2: Создание с помощью функции make_tuple.

Компилятор автоматически определяет тип элементов.

auto simple_tuple = std::make_tuple(“str”, 4, ‘a’, 3.0)

### Для того, чтобы получить элемент, нужно использовать функцию std::get

std::string str = std::get<0>(simple_tuple); // “str” 
int num = std::get<1>(simple_tuple); // 4
char symbol = std::get<2>(simple_tuple); // a
double num_double = std::get<3>(simple_tuple); // 3.0

### Более простой способ получить элементы - использовать функцию std::tie
std::tie(str, num, symbol, num_double) = simple_tuple;


## Constexpr

Constexpr (constant expression) - это ключевое слово, используемое в языке программирования C++. С помощью этого спецификатора можно создавать переменные, функции и объекты и выполнить расчёты на этапе компиляции, вместо того чтобы делать это во время выполнения.

Синтаксис: 
constexpr тип = expression // expression должно быть известно на этапе компиляции
constexpr double pi = 3.14159265; // значение переменной будет вычислено на этапе компиляции

Плюсы:
- часть вычислений можно переложить на компиляцию (этап компиляции будет долгим, зато запуск быстрым)

Минусы:
- невозможно дебажить такие выражения
- много ограничений (чтобы это сработало нужно соблюсти большое количество условий)

### Обязательные условия использовния constexpr

1. Для того чтобы функция могла быть вычислена на этапе компиляции, необходимо добавить к ней спецификатор constexpr перед сигнатурой функции.
А также в точке вызова нужно прописать constexpr.

Рассмотрим пример 1:

constexpr int sum (int v1, int v2) {
	return v1 + v2;
}
constexpr int val = sum (5, 12); 

Данный код использует функцию sum для вычисления суммы двух чисел v1 и v2. Функция sum объявлена как constexpr, что означает, что она может быть вычислена на этапе компиляции. Функция возвращает сумму v1 и v2.

Далее в коде объявляется переменная constexpr val и инициализируется результатом вызова функции sum с аргументами 5 и 12. Так как вызов функции sum происходит на этапе компиляции, переменная val будет вычислена на этапе компиляции.

Таким образом, переменная val будет иметь значение 17, так как 5 + 12 = 17.


Рассмотрим пример 2:

int new_sum (int v1, int v2){
	return v1 + v2;
}
constexpr int val_new = new_sum(4, 5)

Здесь к функции не добавлен спецификатор constexpr. Вычислить её не удастся.

2. Тип данных, используемый в constexpr-контексте, должен быть литеральным типом. Литеральные типы данных включают в себя скалярные типы (например, int, float, double), указатели и массивы скалярных типов.
3. Должно быть сразу присвоено значение или вызыван constexpr конструктор
4. Constexpr функция не может быть вирутальной
5. Constexpr функция должна возвращать литеральный тип (В c++14 можно вернуть void)
6. Все входные параметры constexpr функции должны иметь литеральный тип
7. Тело функции должно содержать ровно один return, который может содержать литералы или constexpr функции

## Нововведения C++14

- Обобщённые лямбда-функции
- Инициализаторы лямбда захвата
- Автоматический вывод типов для функций
- Разделители разрядов

## Обобщённые лямбда-функции

Это возможность использовать auto в лямбда-функции.

Рассмотрим лямбда-функцию, которая используется для сортировки контейнера, хранящего целые числа:   

[](int lhs, int rhs) { return lhs > rhs; }

А если хотим добавить тоже самое, но для контейнера, хранящего вещественные числа? Придется добавить еще одну функцию, отличающуюся только входными типами.

[](double lhs, double rhs) { return lhs > rhs; }

Дублирование кода - это плохо.

Решение: 

Для того, чтобы написать лямбда-функцию, которая работает для всех элементов, можно:
- использовать шаблоны (о них узнаете позже)
- в качестве входного параметра написать auto

[](auto lhs, auto rhs) { return lhs > rhs; }

Код будет работать для всех типов данных, у которых определён оператор > (больше)

Таким образом, мы избежали дублирования кода.


### Инициализаторы лямбда-захвата

Обычно при создании лямбда-выражения в C++ можно захватить переменные из текущего контекста, чтобы иметь к ним доступ внутри лямбда-функции. Однако, в некоторых случаях может потребоваться инициализировать захваченные переменные с определенными значениями. Вот где инициализаторы лямбда-захвата приходят на помощь.

Инициализаторы лямбда-захвата представляются списком инициализаторов в квадратных скобках [ ] перед аргументами лямбда-функции. Каждый инициализатор указывает на переменную, которая должна быть захвачена, и ее начальное значение.

Рассмотрим пример:

auto value {0};
auto function = [value = 5] {return value;}; // вернёт 5


Инициализаторы лямбда-захвата позволяют более гибко управлять захватываемыми переменными и их начальными значениями. Они могут быть полезными, когда нужно устанавливать определенные значения для переменных, которые будут использоваться внутри лямбда-функции.

Благодаря этой возможности, можно использовать захват с перемещением. Захват с перемещением в лямбда-выражениях позволяет перемещать ресурсы вместо их копирования или захвата по ссылке. Использование инициализаторов лямбда-захвата может облегчить захват с перемещением.

Для захвата с перемещением в инициализаторах лямбда-захвата используется синтаксис std::move(). 

Рассмотрим пример:

auto tmp = std::vector<int>(100000, 0);
auto func = [val = std::move(tmp)]{ return val[0]; };

Данный код создает объект std::vector<int> с именем tmp, содержащий 100000 элементов, все инициализированные значением 0. Затем создается лямбда-функция func, которая захватывает tmp с помощью перемещения (используя std::move). Лямбда-функция возвращает значение первого элемента вектора tmp (val[0]).

Таким образом, tmp является временным объектом типа std::vector<int>, который захватывается лямбда-функцией func. Это позволяет использовать tmp внутри лямбда-функции без копирования данных, а только с помощью перемещения.

### Автоматический вывод типов для функций  

Стало возможным не писать возвращаемый тип функции. Мы можем написать auto и тип вычислится позже автоматически.



Рассмотрим пример 1:

auto Correct(int i) {
 if (i == 1)
   return i; // в качестве типа возвращаемого значения выводится int
 else
   return Correct(i - 1) + i; // теперь можно вызывать
}

Рассмотрим пример 2:

auto Wrong(int i) {
 if(i != 1)
   return Wrong(i - 1) + i; // неподходящее место для рекурсии, нет предшествующего возврата
 else
   return i; // в качестве типа возвращаемого значения выводится int
}

Итак:

- Возвращаемая переменная должна быть передана или создана ранее в коде. Мы должны иметь возможность определить её тип явно.
- Если есть несколько точек возврата, то возвращаемое значение должно иметь общий тип.
- Можно использовать рекурсию, но рекурсивный вызов должен выполняться после первого возврата функции.
- Использовать можно после определения, предварительного объявления недостаточно.

### Разделители разрядов 

Можно использовать апостроф для разделения разрядов в числах
Это улучшает читаемость кода

auto big_integer = 1'000'000'000;
auto floating_point = 0.00'021'395'74;
auto binary_literal = 0b00100'0110'0110;



## Нововведения C++17

- Структурированные привязки
- std::variant
- std::optional
- std::any

## Структурированные привязки

Структурированные привязки в C++17 это возможность декомпозировать объекты, такие как массивы, кортежи и структуры, на отдельные переменные с помощью простого синтаксиса.

Ранее в C++ для доступа к элементам массивов или полей структур приходилось использовать индексацию или доступ по имени. Структурированные привязки вводят удобный способ извлечения значений из структур, массивов или кортежей, что делает код более читабельным и лаконичным.

Однако вложенные структуры так не получится декомпозировать. С классами это также не работает.

### Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/eb4adf8e-a290-4fa3-8f6e-0ffbae46f2b4)

У нас есть структура с тремя полями данных:
struct Person {
	std::string name;
	unsigned score;
	std::string birthday;
};

Мы инициализируем объект этой структуры:

Person p1{ "Alex", 70, "03.11.1995" };
auto name = p1.name;
auto score = p1.score;
auto birthday = p1.birthday;

Чтобы получить эти данные раньше необходимо было последовательно, каждый раз обращаясь к объекту класса Person.

В стандарте C++17 появилась возможность использовать структурированные привязки:

auto [name, score, birthday] = p1;

Значения полей из объекта p1 будут присвоены соответствующим переменным name, score и birthday. 
В данном примере названия переменных совпали с именами полей данных, но это не обязательно. 

### Синтаксис структурированных привязок выглядит следующим образом:

auto [var1, var2, ...] = объект;

`var1`, `var2`, ... - это имена переменных, которым будут присвоены значения из объекта, а `объект` - это структура или кортеж, из которых будут извлекаться значения.

Во-первых, мы не думаем про типы. Во-вторых, вместо того, чтобы указывать название каждого из полей данных, мы прописываем переменные, которым будут присвоены значения полей. 

## std::variant


Это такой класс, экземпляр которого в данный момент времени содержит одно значение из альтернативных типов.


std::variant<unsigned, std::string> age; // Позволяет хранить в объекте этого класса одно из двух значений. Переменная age может хранить как число (unsigned) или как строку с датой рождения (std::string). Два типа, которые может в себе совмещать переменная, нужно передать в скобках <>

	
age = 51u; // Инициализируем, работаем как с числом
auto age_int = std::get<unsigned>(age); // Но, чтобы получить эти данные, нужно использовать функцию std::get, явно прописать тип данных - unsigned, передать название переменной, которая является объектом класса std::variant - age

age = "03.05.2014"; // После этого мы меняем значение, работаем как со строкой.
auto age_string = std::get<std::string>(age); // Также использует функцию std::get и указываем тип данных. 

Если мы попробуем из переменной, которая содержит string достать unsigned:

auto tmp = std::get<unsigned>(age);

Появится ошибка: bad_variant_acess. Так как сейчас в переменной age находится тип string.

### Дополнительные функции std::holds_alternative и std::get_if

Помогает проверить тип данных, который в данный момент используется.

Рассмотрим пример:

std::variant<unsigned, std::string> age; 
	
age = 51u; // работаем как с числом

bool is_string = std::holds_alternative<std::string>(age); // false
bool is_unsigned = std::holds_alternative<unsigned>(age); // true

Мы создали переменную std::variant, в треугольных скобках указали, что здесь может лежать либо unsigned, либо string. Решили работать с этим как с числом, присвоили age = 51u. 

Дальше мы хотим узнать, что именно лежит в объекте класса age. 

Вызываем функцию std::holds_alternative, в треугольных скобках передаём тип проверку которого мы хотим произвести. Дальше прописываем название самой переменной.

Если функция в данный момент содержит тот тип данных, который мы пытаемся получить, то результат будет true.
Если она содержит другой тип данных, то результат будет false.

Функция get_if позволяет вернуть данные, если их тип соответствует типу, укзанному в треугольных скобках.

auto try_string = std::get_if<std::string>(&age) // nullptr, не получается, так как там лежит 51u. 
auto tmp = std::get_if<unsigned>(age); // unsigned int *, возвращает значение.


## std::optional

Это класс, который может содержать значение, а может не содержать ничего. С помощью него удобно показать, что функция может не возвращать значение.

Рассмотрим пример:

Функция my_sqrt возвращает квадратный корень из переданного значения.

std::optional<double> my_sqrt(double val) {
    if (val < 0) // корень из 0 или отрицательного числа не вычисляем
        return {}; // если 0 или отрицательное значение, возвращаем пустые фигурные скобки
    else
        return sqrt(val);
}

Вызов из этой функции: 

### Метод value_or

double v = my_sqrt(-5).value_or(0); 

my_sqrt - название функции
(-5) - передаём какое-то значение
вызываем метод value_or
(0) - прописываем значение, которое будет присвоено, если у нас пустые фигурные скобки

Мы попытались вычислить квадратный корень из -5. Получили 0

double v1 = my_sqrt(4).value_or(0); // 2

В этом случае, мы вычисляем квадратный корень из 4 и получаем значение 2.

Итак: value_or(arg) - возвращает значение, если оно хранится, либо возвращает число в arg

### Метод has_value

has_value - проверяет, содержится значение или нет

bool has_value = my_sqrt(-5).has_value(); // false
bool has_value1 = my_sqrt(4).has_value(); // true

### std::any

Это класс, который может хранить значения разных копируемых типов (не путать с auto).
Если auto определяется на этапе компиляции, то std::any - это динамический тип, который может работать с разными типами данных.

### Рассмотрим пример 1:

std::any a = 5; 
std::cout << a.type().name() << ": " << std::any_cast<int>(a) << '\n'; 

Функция std::any_cast используется для извлечения значения из объекта std::any. В данном случае, тип, переданный в std::any_cast<int>, указывает, что значение должно быть приведено к типу int.

В результате выполнения программы будет выведено сообщение int: 5, что указывает на тип переменной a (int) и ее значение (5).

### Рассмотрим пример 2:

a = 3.14;
std::cout << a.type().name() << ": " << std::any_cast<double>(a) << '\n';

В данном случае, тип, переданный в std::any_cast<double>, указывает, что значение должно быть приведено к типу double.

В результате выполнения программы будет выведено сообщение double: 3.14, что указывает на тип переменной a (double) и ее значение (3.14).

Итак, можно воспользоваться функцией type, которая вернёт объект typeinfo, у которого можем узнать тип.
Получить значение можно с помощью any_cast. 
Если значение преобразовываем не к тому типу, который находится, то получим исключение bad_cast.

Также можно проверить содержит ли значение:
bool has_value = a.has_value()

Можно хранить значения любых типов в одном контейнере:
std::vector<any> v { "test_string", 4.12, 5, false};

Используется, когда требуется создать контейнер, в котором можно хранить элементы разных типов.











