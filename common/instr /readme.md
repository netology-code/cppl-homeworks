# Новшества С++

Автор лонгрида: Максим Бакиров
- В C++ разработке с 2017 года
- С 2019 года работает в команде разработки Яндекс Браузера

Цели занятия:
- Разберём основные новшества 11, 14, 17 стандартов
- Увидим, что C++ может быть красивым и понятным
- Познакомимся с мощью современного C++

## Стандарт языка С++

### Откуда берутся стандарты
Существует Комитет ISO по стандартизации языка C++:
- создает новые версии языка
- утверждает международные стандарты

Первый стандарт C++ вышел в 1985 г.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/instr/1.png)

Современный C++ начинается с 2011 г. После версии C++11 новые стандарты выходили каждые 3 года.

## Нововведения C++11

- Ключевое слово auto
- Range based for
- Лямбда-функции
- Спецификаторы override и final
- Семантика перемещения
- Умные указатели
- Кортежи
- Constexpr

## Ключевое слово auto

Ключевое слово «auto» в C++11 позволяет компилятору автоматически выводить тип переменной на основе значения, с которым эта переменная была проинициализирована.

В старых версиях C++, требовалось явно указывать тип переменной при ее объявлении, например:

int x = 10 (переменная x типа int, 10 - её инициализатор)

В C++11 вместо явного указания типа можно использовать ключевое слово «auto», которое позволяет компилятору самостоятельно определить тип переменной на основе её инициализатора, например:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/2.PNG)

Компилятор на основе числа 5 определил тип переменной int. 
На основе числа 4.0 - тип double, который используется для хранения чисел с плавающей точкой.
Также «auto» сработало и для объекта кастомного класса my_class ().

«Auto» будет работать и с возвращаемыми значениями функций. 
Например, функция add, которая возвращает int. В этом случае можно использовать «auto», чтобы принять этот результат:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/3.PNG)

### «Auto» удобно использовать, когда мы не знаем, какой тип будет иметь переменная.

Для примера рассмотрим функцию без определённого типа данных. 
Тип данных a и b, а также возращаемого значения будет определяться в зависимости от того, какие параметры мы туда передадим.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/5.PNG)

Если мы укажем целые числа, например, 3 и 5, то тип данных (T) будет int

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/8.PNG)

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/7.PNG)

Если мы укажем числа с точкой, например, 3.0 и 5.3, то тип данных (T) будет duble

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/9.PNG)

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/10.PNG)

### В C++11 нет возможности применения «auto» для типа отображаемых данных. 

Вместо этого, вам необходимо указать конкретные типы параметров.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/11.PNG)

### Чем полезно использование «auto»:
- Улучшает абстракцию: принуждает думать в терминах интерфейсов, а не реализаций. Мы поднимаемся на уровень выше, когда думаем не о самом объекте, а том, как его можно применить.
- Заставляет инициализировать переменные, что избавляет от ситуаций, когда в переменной лежит что-то не то.
- Безопасность и быстрота: нельзя опечататься в имени типа или случайно использовать другой, к которому есть неявное приведение.
- Стабильность: если тип функции изменится, то меньше случаев, когда код придется менять.
- Также «auto» сокращает код, часто помогает при работе с std.

Рассмотрим удобство «auto» для сокращения кода. 
Есть прототип некоторой функции:

std::map<std::string, std::vector<int>> some_func();

И каждый раз результат выполнения функции нужно будет сохранять в переменную типа:

std::map<std::string, std::vector<int>>

А можно написать короче:

auto result = some_func()

### Итак, важные особенности использования «auto»:
- Переменная «auto» должна быть проинициализирована.
- Переменная «auto» не может быть членом класса. Компилятор должен иметь информацию о типе, чтобы выделить память для объекта класса и правильно выполнять доступ к его полям и методам. Поэтому требуется явное указание типа для членов класса, а использование «auto» не допускается.
- Переменная «auto» не может быть параметром функции (до С++14).
- Тип «auto» не может быть возвращаемым типом функции (до С++11).


## Range based for

Range-based for loop — это функциональность, введенная в C++11, которая позволяет проходить через элементы контейнера (такого как массив, вектор, list и т.д.) более простым и интуитивно понятным способом. 

Синтаксис Range for следующий:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/24.PNG)

### Рассмотрим, как работает классический способ:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/12.PNG)

У нас есть статический массив arr, который содержит в себе интовые элементы:

int arr[]{ 1,2,3,4,2,1,3 };

А также контейнер std::vector, который предоставляет динамический массив объектов одного типа (для использования std::vector, необходимо включить заголовочный файл <vector> и использовать пространство имен std).

std::vector<int> vi{ 1,2,3,4,5 };

Мы можем пройтись по элементам вектора классическим образом:

for (int i = 0; i < vi.size(); i++) {
	std::cout << vi[i] << "\t";
}

После компиляции мы распечатаем все элементы контейнера:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/13.PNG)

### Рассмотрим, как это будет работать с Range-based for

Поскольку у нас интовый вектор, то мы пишем:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/14.PNG)

Нужно запомнить синтксис:

for (int i : vi)

int i  - тип переменной i должен совпадать с типом объектов, которые содержит контейнер (в данном примере они интовые: vi{ 1,2,3,4,5 })
vi - название контейнера, по которому мы ходим

Каждый объект, который содержится в контейнере vi{ 1,2,3,4,5 } последовательно помещается в переменную i. 

То есть, мы проходимся по всему диапазону, в котором лежат элементы контейнера. 

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/15.PNG)

Это будет работать и с массивом arr:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/16.PNG)

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/17.PNG)

Итак, стандартный for можно использовать как foreach (цикл, основанный на диапазоне).

### Идеально использовать с «auto»

Например, если массив arr инициализируется числами типа double или используются объекты кастомного класса my_class (), удобно использовать «auto»:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/18.PNG)

Важно, чтобы у этого класса был перегружен оператор вывода в консоль. В языке C++ для вывода информации в консоль используется оператор вывода <<, который можно использовать с объектом типа std::cout из стандартной библиотеки iostream.

Если вы не модифицируете данные, лучшей практикой будет использование «const auto &». Так в переменной i не будет постоянно происходить копирование.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/20.PNG)

###  Range-based for не может быть использован с динамическими массивами, которые не являются контейнерами и не поддерживают итераторы

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/21.PNG)

Данный код создает массив arr типа int и инициализирует его значениями {1,2,3,4,2,1,3}.
Затем создается вектор vi типа std::vector<int> и инициализируется значениями {1,2,3,4,5}.
Затем создается указатель arr_d типа int* и выделяется динамическая память для массива размером 5 элементов. Элементы инициализируются значением 0. 

Далее, в цикле for каждое значение i массива arr_d выводится в консоль с помощью std::cout << i << "\t";. 

Однако, в цикле for возникает ошибка. Range-based for требует функцию "begin", которая не была обнаружена.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/22.PNG)

Давайте разберём, почему возникла эта ошибка.

### Методы begin, end

Это методы, которые предоставляют итератор на начало и конец контейнера. Они используются для перебора элементов контейнера в цикле for. 

Например:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/23.PNG)

Здесь мы перебираем элементы вектора с помощью итератора. 
vec.begin() возвращает итератор, указывающий на начало вектора, а vec.end() возвращает итератор, указывающий за конец вектора. Мы перемещаем итератор по вектору с помощью оператора инкремента it++ и проверяем, не достигли ли мы конца вектора с помощью условия it !=

В нашем примере выше:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/22.PNG)

int arr[]{ 1,2,3,4,2,1,3 }; У arr тип данных - int [7]
std::vector<int> vi{ 1,2,3,4,5 }; Стандартный контейнер std::vector
int* arr_d = new int[5] {0}; Здесь тип - int *. Это указатель на динамический массив. 

В данном случае, цикл for пытается перебрать значения указателя на массив int arr_d, но этот указатель не является диапазоном и не имеет функции begin, которую требует цикл for.

### Итак, особенности использования Range-based for:
- Массивы, контейнеры и коллекции должны иметь методы begin, end
- Объект итерации должен поддерживать операцию ++
- Объект итерации должен поддерживать оператор !=

## Лямбда-функции

Лямбда-функции - это анонимные функции, которые могут быть определены и использованы внутри других функций, включая глобальные функции. 
Они были введены в C++11 и стали очень популярными за свою компактность и удобство использования, особенно при работе с алгоритмами стандартной библиотеки.

Её синтаксис:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/25.PNG)


[=] - Список захвата переменных, который определяет переменные из внешней области видимости, доступные внутри лямбда-функции. То есть, вы можете захватить любую переменную из той области видимости, в которой вы инициализируете данную функцию.

() - Параметры функций. Перечисляем, какие параметры будут приниматься этой функцией.

mutable - Изменяемая спецификация (необязательный параметр). Так вы говорите, что можете модифицировать переменные, которые захватили.

throw - Спецификация исключений (необязательный параметр). Мы должны явно указать, может ли функция выбросить исключения.

int - Возвращаемый тип функции (условно необязательный параметр)

 {
        //do something
        return x + y;
    }                     Тело функции
    

### Рассмотрим на простом примере:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/26.PNG)

Функция складывает два числа:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/27.PNG)

Основные составляющие:

[] - Список захвата переменных, который определяет, какие внешние переменные доступны лямбда-функции. В данном случае список пуст. Это означает, что данная лямбда-функция не захватывает никакие внешние переменные.

(auto a, auto b) - Входные параметры функции

{
        return a + b;
        }; - Тело функции

### Зачем это нужно?

Часто бывает ситуация, когда необходимо некоторую функцию передать как параметр в другую функцию. Например, в стандартную функцию std::sort для сортировки ваших классов.

Старое решение: объявить функцию где-то и передать по указателю
Минусы: загромождает код и область видимости

Новое решение: использовать лямбда-функции

### Рассмотрим пример без лямбда функции:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/29.PNG)

Есть структура exam_results, которая представляет собой дневник с оценками учеников.

Она содержит 2 поля:
std::string name; - имя студента
int score; - оценка студента

Функция `comparator` (функция сравнения) принимает два аргумента типа `exam_results` и сравнивает их по полю `score`. Если оценка первого студента (`lhs`) больше оценки второго студента (`rhs`), функция возвращает `true`, иначе `false`.

В функции `main` создается вектор `results`, содержащий несколько элементов типа `exam_results` с заданными именами и оценками.

std::vector<exam_results> results{ 
		{"Alex", 55}, {"Igor", 87}, {"Alena", 69} 

Затем вызывается функция `std::sort`, которая сортирует элементы вектора `results` с использованием компаратора `comparator`. Это означает, что элементы вектора будут отсортированы по убыванию оценок (от большей к меньшей).

Чтобы вывести результаты сортировки, можно использовать цикл `for` для прохода по элементам вектора и вывода их содержимого на экран:

for (const auto &result : results) {
   std::cout << result.name << " " << result.score << std::endl;
}

Этот кусок кода будет проходить через каждый элемент в results и выводить имя и результат на экзамене на консоль.

В результате выполнения программы, элементы вектора `results` будут отсортированы следующим образом:

1. "Igor", 87
2. "Alena", 69
3. "Alex", 55

![Image alt](  https://github.com/netology-code/cppl-homeworks/blob/main/common/30.PNG)

Минусы этого кода:

Мы зарезервировали имя `comparator`. Оно принадлежит именно этой совокупности дейстивий.
Но, что, если в следующий раз мы захотим отсортировать не по среднему баллу, а по длине имени ученика. 
Каждый раз нужно будет создавать `comparator`. Это дублирование кода и засорение пространства имён.

### Тот же пример с лямбда-функцией:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/31.PNG)











