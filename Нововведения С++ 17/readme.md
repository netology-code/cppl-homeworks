# Нововведения C++17

1. Структурированные привязки
2. std::variant
3. std::optional
4. std::any

## 1. Структурированные привязки

Структурированные привязки в C++17 это возможность декомпозировать объекты, такие как массивы, кортежи и структуры, на отдельные переменные с помощью простого синтаксиса.

Ранее в C++ для доступа к элементам массивов или полей структур приходилось использовать индексацию или доступ по имени. Структурированные привязки вводят удобный способ извлечения значений из структур, массивов или кортежей, что делает код более читабельным и лаконичным.

Однако вложенные структуры так не получится декомпозировать. С классами это также не работает.

### Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/a9254b48-b9d9-435c-ad2a-09f552235876)


У нас есть структура `struct Person {` с тремя полями данных:

`std::string name;`

`unsigned score;`

`std::string birthday;`

Мы инициализируем объект этой структуры:

`Person p1{ "Alex", 70, "03.11.1995" };`

`auto name = p1.name;`

`auto score = p1.score;`

`auto birthday = p1.birthday;`

Чтобы получить эти данные раньше необходимо было последовательно, каждый раз обращаясь к объекту класса `Person`.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/14e1d5af-23e0-4d81-8568-cbb314381d11)


В стандарте C++17 появилась возможность использовать структурированные привязки:

`auto [name, score, birthday] = p1;`

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/2b9404ed-0237-470e-ae0d-bf521f3e0fe8)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/6f1d6fec-f8c4-4154-9697-f23a3f1fed8c)


Значения полей из объекта `p1` будут присвоены соответствующим переменным `name`, `score` и `birthday`. 
В данном примере названия переменных совпали с именами полей данных, но это не обязательно. Переменные могут называться как угодно.

### Синтаксис структурированных привязок выглядит следующим образом:

`auto [var1, var2, ...] = объект;`

`var1`, `var2`, ... - это имена переменных, которым будут присвоены значения из объекта, а `объект` - это структура или кортеж, из которых будут извлекаться значения.

Во-первых, мы не думаем про типы. Во-вторых, вместо того, чтобы указывать название каждого из полей данных, мы прописываем переменные, которым будут присвоены значения полей. 

## 2. std::variant


Это такой класс, экземпляр которого в данный момент времени содержит одно значение из альтернативных типов.

Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/1fc832bc-77fc-4a06-a030-c6883cbdcc04)


`std::variant<unsigned, std::string> age;` // Позволяет хранить в объекте этого класса одно из двух значений. Переменная age может хранить как число (unsigned) или как строку с датой рождения (std::string). Два типа, которые может в себе совмещать переменная, нужно передать в скобках <>

`age = 51u;`// Инициализируем, работаем как с числом

`auto age_int = std::get<unsigned>(age);` // Но, чтобы получить эти данные, нужно использовать функцию std::get, явно прописать тип данных - unsigned, передать название переменной, которая является объектом класса std::variant - age

`age = "03.05.2014";` // После этого мы меняем значение, работаем как со строкой.

`auto age_string = std::get<std::string>(age);` // Также использует функцию std::get и указываем тип данных. 

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/487efa6e-2306-4a5c-989c-ad3dee9b8655)

Если мы попытаемся получить значение типа `unsigned` из объекта `age`, хотя объект `age` был присвоен значению типа `std::string`. Это вызывает исключение std::bad_variant_access, поскольку типы не соответствуют:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/100b8d33-e336-4eb9-aa24-fca114709f93)


### Дополнительные функции std::holds_alternative и std::get_if

Помогает проверить тип данных, который в данный момент используется.

Рассмотрим пример:

`std::variant<unsigned, std::string> age;`
	
`age = 51u;` // работаем как с числом

`bool is_string = std::holds_alternative<std::string>(age);` // false

`bool is_unsigned = std::holds_alternative<unsigned>(age);` // true

Мы создали переменную `std::variant`, в треугольных скобках указали, что здесь может лежать либо `unsigned`, либо `string`. Решили работать с этим как с числом, присвоили `age = 51u`. 

Дальше мы хотим узнать, что именно лежит в объекте класса `age`. 

Вызываем функцию `std::holds_alternative`, в треугольных скобках передаём тип проверку которого мы хотим произвести. Дальше прописываем название самой переменной.

Если функция в данный момент содержит тот тип данных, который мы пытаемся получить, то результат будет `true`.
Если она содержит другой тип данных, то результат будет `false`.

Функция `get_if` позволяет вернуть данные, если их тип соответствует типу, укзанному в треугольных скобках.

`auto try_string = std::get_if<std::string>(&age)` // nullptr, не получается, так как там лежит 51u. 

`auto tmp = std::get_if<unsigned>(age);` // unsigned int *, возвращает значение.


## std::optional

Это класс, который может содержать значение, а может не содержать ничего. С помощью него удобно показать, что функция может не возвращать значение.

Рассмотрим пример:

Функция `my_sqrt` возвращает квадратный корень из переданного значения.

`std::optional<double> my_sqrt(double val) {`

`if (val < 0)` // корень из 0 или отрицательного числа не вычисляем
    
`return {};` // если 0 или отрицательное значение, возвращаем пустые фигурные скобки
        
`else`
    
`return sqrt(val);`
        
`}`

Вызов из этой функции: 

### Метод value_or

`double v = my_sqrt(-5).value_or(0);` 

`my_sqrt` - название функции

`(-5)` - передаём какое-то значение

вызываем метод `value_or`

`(0)` - прописываем значение, которое будет присвоено, если у нас пустые фигурные скобки

Мы попытались вычислить квадратный корень из -5. Получили 0

`double v1 = my_sqrt(4).value_or(0);` // 2

В этом случае, мы вычисляем квадратный корень из 4 и получаем значение 2.

Итак: `value_or(arg)` - возвращает значение, если оно хранится, либо возвращает число в `arg`.

### Метод has_value

`has_value` - проверяет, содержится значение или нет

`bool has_value = my_sqrt(-5).has_value();` // false

`bool has_value1 = my_sqrt(4).has_value();` // true

### std::any

Это класс, который может хранить значения разных копируемых типов (не путать с auto).
Если `auto` определяется на этапе компиляции, то `std::any` - это динамический тип, который может работать с разными типами данных.

### Рассмотрим пример 1:

`std::any a = 5;`

`std::cout << a.type().name() << ": " << std::any_cast<int>(a) << '\n';`

Функция `std::any_cast` используется для извлечения значения из объекта `std::any`. В данном случае, тип, переданный в `std::any_cast<int>`, указывает, что значение должно быть приведено к типу `int`.

В результате выполнения программы будет выведено сообщение int: 5, что указывает на тип переменной a (int) и ее значение (5).

### Рассмотрим пример 2:

`a = 3.14;`

`std::cout << a.type().name() << ": " << std::any_cast<double>(a) << '\n';`

В данном случае, тип, переданный в `std::any_cast<double>`, указывает, что значение должно быть приведено к типу `double`.

В результате выполнения программы будет выведено сообщение double: 3.14, что указывает на тип переменной a (double) и ее значение (3.14).

Итак, можно воспользоваться функцией `type`, которая вернёт объект `typeinfo`, у которого можем узнать тип.

Получить значение можно с помощью `any_cast`. 

Если значение преобразовываем не к тому типу, который находится, то получим исключение `bad_cast`.

Также можно проверить содержит ли значение:

`bool has_value = a.has_value()`

Можно хранить значения любых типов в одном контейнере:

`std::vector<any> v { "test_string", 4.12, 5, false};`

Используется, когда требуется создать контейнер, в котором можно хранить элементы разных типов.












