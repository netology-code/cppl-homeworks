# Range based for

Range-based for loop — это функциональность, введенная в C++11, которая позволяет проходить через элементы контейнера (такого как массив, вектор, list и т.д.) более простым и интуитивно понятным способом. 


## Рассмотрим, как работает классический способ вывода содержимого контейнера:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/12.PNG)



У нас есть массив arr, который содержит в себе элементы типа int:

`int arr[]{ 1,2,3,4,2,1,3 };`

А также контейнер std::vector, который предоставляет динамический массив объектов одного типа (для использования std::vector, необходимо включить заголовочный файл <vector> и использовать пространство имен std):

`std::vector<int> vi{ 1,2,3,4,5 };`

Мы можем пройтись по элементам вектора классическим образом:

`for (int i = 0; i < vi.size(); i++) {`


`std::cout << vi[i] << "\t";`


`}`

После компиляции мы распечатаем все элементы контейнера:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/13.PNG)



## Рассмотрим, как это будет работать с Range-based for

Синтаксис Range for следующий:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/24.PNG)



Поскольку у нас интовый вектор, то мы пишем:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/14.PNG)



Нужно запомнить синтксис:

`for (int i : vi)`

`int i`  - тип переменной `i` должен совпадать с типом объектов, которые содержит контейнер (в данном примере они интовые: vi{ 1,2,3,4,5 })


`vi` - название контейнера, по которому мы ходим

Каждый объект, который содержится в контейнере `vi{ 1,2,3,4,5 }` последовательно помещается в переменную `i`. 

То есть, мы проходимся по всему диапазону, в котором лежат элементы контейнера. 

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/15.PNG)



Это будет работать и с массивом `arr`:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/16.PNG)



![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/17.PNG)



Итак, стандартный `for` можно использовать как `foreach` (цикл, основанный на диапазоне).

## Идеально использовать с «auto»

Например, если массив `arr` инициализируется числами типа `double` или используются объекты кастомного класса `my_class ()`, удобно использовать `auto`:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/18.PNG)



Важно, чтобы у этого класса был перегружен оператор вывода в консоль. В языке C++ для вывода информации в консоль используется оператор вывода `<<`, который можно использовать с объектом типа `std::cout` из стандартной библиотеки `iostream`.

Если вы не модифицируете данные, лучшей практикой будет использование `const auto &`. Так в переменной `i` не будет постоянно происходить копирование.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/20.PNG)



## Range-based for не может быть использован с динамическими массивами, которые не являются контейнерами и не поддерживают итераторы

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/21.PNG)



Данный код создает массив `arr` типа `int` и инициализирует его значениями `{1,2,3,4,2,1,3}`.


Затем создается вектор `vi` типа `std::vector<int>` и инициализируется значениями `{1,2,3,4,5}`.


Затем создается указатель `arr_d` типа `int*` и выделяется динамическая память для массива размером 5 элементов. Элементы инициализируются значением 0. 


Далее, в цикле `for` каждое значение `i` массива `arr_d` выводится в консоль с помощью `std::cout << i << "\t";`. 


Однако, в цикле `for` возникает ошибка. Range-based for требует функцию `begin`, которая не была обнаружена.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/22.PNG)



Давайте разберём, почему возникла эта ошибка.

## Методы begin, end

Это методы, которые предоставляют итератор на начало и конец контейнера. Они используются для перебора элементов контейнера в цикле `for`. 

Например:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/23.PNG)


Здесь мы перебираем элементы вектора с помощью итератора. 


`vec.begin()` возвращает итератор, указывающий на первый элемент вектора, а `vec.end()` возвращает итератор, следующий за последним элементом вектора. 

Мы перемещаем итератор по вектору с помощью оператора инкремента `it++` и проверяем, не достигли ли мы конца вектора с помощью условия `it !=`

В нашем примере выше:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/22.PNG)

`int arr[]{ 1,2,3,4,2,1,3 };` // У arr тип данных - int [7]


`std::vector<int> vi{ 1,2,3,4,5 };` // Стандартный контейнер std::vector


`int* arr_d = new int[5] {0};` // Здесь тип - int *. Это указатель на динамический массив. 

В данном случае, цикл `for` пытается перебрать значения указателя на массив `int arr_d`, но этот указатель не является диапазоном и не имеет функции `begin`, которую требует цикл `for`.

## Итак, особенности использования Range-based for:
- Массивы, контейнеры и коллекции должны иметь методы `begin`, `end`
- Объект итерации должен поддерживать операцию `++`
- Объект итерации должен поддерживать оператор `!=`

