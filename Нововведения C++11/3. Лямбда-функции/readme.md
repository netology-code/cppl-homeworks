# Лямбда-функции

Лямбда-функции - это анонимные функции, которые могут быть определены и использованы внутри других функций, включая глобальные функции. 
Они были введены в C++11 и стали очень популярными за свою компактность и удобство использования, особенно при работе с алгоритмами стандартной библиотеки.

Синтаксис:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/25.PNG)


`[=]` - Список захвата переменных, который определяет переменные из внешней области видимости, доступные внутри лямбда-функции. То есть, вы можете захватить любую переменную из той области видимости, в которой вы инициализируете данную функцию.

`()` - Параметры функций. Перечисляем, какие параметры будут приниматься этой функцией.

`mutable` - Изменяемая спецификация (необязательный параметр). Так вы говорите, что можете модифицировать переменные, которые захватили.

`throw` - Спецификация исключений (необязательный параметр). Мы должны явно указать, может ли функция выбросить исключения.

`int` - Возвращаемый тип функции (условно необязательный параметр).
  

## Рассмотрим на простом примере:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/26.PNG)


Функция складывает два числа.

Основные составляющие:

`[]` - Список захвата переменных, который определяет, какие внешние переменные доступны лямбда-функции. В данном случае список пуст. Это означает, что данная лямбда-функция не захватывает никакие внешние переменные.

`(auto a, auto b)` - входные параметры функции

`{
        return a + b;
        };`        - тело функции

## Зачем это нужно?

Часто бывает ситуация, когда необходимо некоторую функцию передать как параметр в другую функцию. Например, в стандартную функцию `std::sort` для сортировки ваших классов.

Старое решение: объявить функцию где-то и передать по указателю.
Минусы: загромождает код и область видимости.

Новое решение: использовать лямбда-функции.

## Рассмотрим пример без лямбда функции:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/29.PNG)


1. Есть структура `exam_results`, которая представляет собой дневник с оценками учеников. Она содержит 2 поля:

`std::string name;` - имя студента


`int score;` - оценка студента


2. Функция `comparator` (функция сравнения) принимает два аргумента типа `exam_results` и сравнивает их по полю `score`. Если оценка первого студента (`lhs`) больше оценки второго студента (`rhs`), функция возвращает `true`, иначе `false`.

3. В функции `main` создается вектор `results`, содержащий несколько элементов типа `exam_results` с заданными именами и оценками.


`std::vector<exam_results> results{` 

`{"Alex", 55}, {"Igor", 87}, {"Alena", 69}`

4. Затем вызывается функция `std::sort`, которая сортирует элементы вектора `results` с использованием компаратора `comparator`. Это означает, что элементы вектора будут отсортированы по убыванию оценок (от большей к меньшей).
   
5. Чтобы вывести результаты сортировки, можно использовать цикл `for` для прохода по элементам вектора и вывода их содержимого на экран:
   

`for (const auto &result : results) {`


   `std::cout << result.name << " " << result.score << std::endl;`

   
`}`


Этот кусок кода будет проходить через каждый элемент в `results` и выводить имя и результат на экзамене на консоль.


6. В результате выполнения программы, элементы вектора `results` будут отсортированы следующим образом:


![Image alt](  https://github.com/netology-code/cppl-homeworks/blob/main/common/30.PNG)


Минусы этого кода:

- Мы зарезервировали имя `comparator`. Оно принадлежит именно этой совокупности дейстивий.
- Но, что, если в следующий раз мы захотим отсортировать не по среднему баллу, а по другому параметру.
- Каждый раз нужно будет создавать `comparator`. Это дублирование кода и засорение пространства имён.


## Тот же пример с лямбда-функцией:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/31.PNG)


В первой части кода всё остаётся по-прежнему:

1. Есть структура `exam_results`, которая содержит два поля: `name` (имя студента) типа `std::string` и `score` (оценка) типа `int`.

2. В функции `main()` создан вектор `results`, который содержит объекты типа `exam_results`. 

3. Вектор заполняется тремя элементами: `{ "Alex", 55 }, { "Igor", 87 }, { "Alena", 69 }`.

4. Используется функция `std::sort`. 

Обратите внимание, мы и здесь передаём границы массива данных, который хотим сортировать: `results.begin()`, `results.end()`.

5. Во второй части кода прописываем лямбда-функцию, то есть инициализируем функцию прямо в вызове другой функции.

Входные параметры лямбда-функции такие же, как в предыдущем варианте кода: `(const exam_results& lhs, const exam_results& rhs)`. Функция возвращает `true`, если балл студента слева больше, чем балл студента справа.

В теле функции то же действие, которое мы совершали с помощью `comparator`. Нам нужно вернуть результат сравнения двух параметров.

`{`


`return lhs.score > rhs.score;`

  
   `}`

## Рассмотрим ещё один пример, чтобы убедиться, насколько лямбда-функции полезны:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/33.PNG)


Данный код сортирует вектор строк `vs` в порядке возрастания и выводит отсортированные строки на экран.


1. Программа начинается с объявления и инициализации вектора строк `vs`, содержащего строки "ab", "bcae" и "cbad".

2. Затем вызывается функция `std::sort`, которая сортирует элементы вектора в заданном диапазоне, переданном ей в качестве аргументов. В данном случае, сортируются все элементы вектора `vs`. Функция `std::sort` использует алгоритм сортировки по умолчанию, который сортирует элементы лексикографически.

3. После сортировки, следующий цикл `for` перебирает каждый элемент вектора `vs` и выводит его на экран с помощью функции `std::cout`. Здесь `const auto & s` означает, что тип элемента вектора будет выводиться автоматически, а `&` означает, что элемент должен быть константной ссылкой, чтобы избежать копирования элемента в цикле.

4. Таким образом, результатом работы программы будет следующий вывод:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/34.PNG)

В данном примере элементы сортируются лексикографически. Но, что если нам нужно сравнить их по размеру.

Имплементируем лямбда-функцию:

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/36.PNG)

Здесь используется лямбда-функция, которая сравнивает две строки по их длине. 

Если длина первой строки `(lhs)` больше длины второй строки `(rhs)`, то возвращается `true` и происходит перестановка, чтобы отсортировать строки по убыванию их длины.

![Image alt](https://github.com/netology-code/cppl-homeworks/blob/main/common/37.PNG)

Таким образом, мы ввели нетривиальное правило сравнения и сделали это без создания новых функций.

Если мы захотим сравнить параметры ещё по каким-то принциам, то у нас не будет необходимости создавать всё новые и новые функции, засорять ими пространство.

## Захват переменных []

Список захвата определяет переменные, которые будут доступны внутри лямбда-функции. Таким образом, мы указываем, что должно попасть в функцию.

Как вы думаете, скомпилируется ли данная функция:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/99c394ff-cbe4-430b-9783-007f00f3bb84)

Нет, так как лямбда-функция ничего не знает про переменную `val`. 

Для лямбда-функции работают те же правила, что и для любых других функций. Она имеет свою собственную область видимости и стек вызовов, в которых хранятся локальные переменные и аргументы функции. 


В данно примере в локальном стеке нет объекта `val`.

Для того, чтобы у лямбда-функции был доступ к использованию переменной `val`, мы её добавляем в список захвата:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/51567e83-d23f-4f28-a6c3-b3f4b5aa73e6)

Всё, что находится в контексте квадратных скобок `[]` является списком захвата. И, если мы хотим дать функции возможность использовать какую-то из переменных, мы добавляем её в квадратные скобки.

## Можно захватить все переменные из области видимости, где объявлена лямбда-функция, по ссылке [&] или значению [=].

Посмотрим, как это работает с захватом по ссылке `[&]`

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/4dfc7b7a-8512-4b52-878a-edf511522c7b)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/2b6499be-c0f5-4bf7-8c23-24c2b5933b12)

С захватом по значению `[=]` получим тот же результат:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/3288f8ed-a406-40b1-a42b-bf352ffb72f4)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/832bcaca-f755-465a-beae-272e421744ee)

Разница между `[&]` и `[=]` в способе захвата переменных оператором захвата при создании лямбда-функции:

1. Захват по ссылке `[&]`:
- Позволяет лямбда-функции получить доступ к переменным внутри ее области видимости по ссылке.
- Изменения, внесенные в переменные внутри лямбда-функции, будут отражаться на соответствующих переменных вне лямбда-функции.
- Переменные, захваченные по ссылке, могут быть изменены даже после завершения работы лямбда-функции.

2. Захват по значению `[=]`:
- Создает копию переменных из области видимости и передает их в лямбда-функцию.
- Лямбда-функции работают с этими копиями, поэтому изменения внутри нее не влияют на значения исходных переменных.
- Когда лямбда-функция завершает работу, копии переменных уничтожаются.

Таким образом, `[&]` позволяет лямбда-функции изменять значения переменных в области видимости, в то время как `[=]` передает только значения переменных и не позволяет их изменять.

## Можно часть переменных захватывать по ссылке, часть по значению:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/5dd1563d-edf1-431f-8da1-0aa1c9367850)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/36b71fd1-5b99-492d-b66a-ad4e4211e6b4)


## Здесь все также как в обычных функциях. Сколько параметров укажем при создании лямбды, столько обязаны использовать при её вызове:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/c8a4f20f-16dd-426e-a4f2-e831f9e3533d)

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/78af916c-488f-4cfb-abb1-67c6bbeb78b9)


## Для того, чтобы захватить методы класса, нужно захватить this

Лямбда-функции могут захватывать переменные из своей окружающей области видимости, включая поля и методы класса. Однако, чтобы использовать методы класса внутри лямбда-функции, нужно передать указатель `this`, который представляет текущий экземпляр класса. Это позволяет лямбда-функции получить доступ к методам и полям конкретного экземпляра класса, с которым она работает.


## Спецификатор mutable

Данный спецификатор говорит о том, что внутри лямбда-функции можно изменять переменные, захваченные не по ссылке.

Рассмотрим перый пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/20cfc2b2-3813-41fc-829e-32ccf72a4785)

Код вызовет ошибку компиляции. 

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/476a9286-2fb7-4daa-b6ff-f23dba9e0b41)

Поскольку `val` захватывается по значению, изменения, внесенные лямбда-функцией, не отражаются на исходной переменной `val`. Это означает, что увеличение `val` внутри лямбды не изменит значение исходной переменной `val`.

Если мы создадим захват по ссылке:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/ea13250b-e96e-420c-bec7-8022073bb0e5)

Лямбда-функция `func` захватывает переменную `val` по ссылке (что означено символом `&`) и увеличивает её значение на 1.

На этот раз значение `val` равно 1, так как `val` был увеличен на один внутри `func`:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/85d89438-d9cc-4e1d-9c03-6830011cfba2)

Но, если мы можем менять само значение, почему мы не можем менять копию?

Для того, чтобы работать с копией мы должны прописать спецификатор `mutable`.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/e9788b1d-bf94-4518-a022-4bfe04921a6a)


Спецификатор `mutable` позволяет изменять значения переменных, захваченных лямбда-функцией по значению. Однако, важно понимать, что даже если `val` изменяется внутри лямбда-функции, это не влияет на исходную переменную `val`, определенную вне лямбда-функции.

Это связано с тем, что значение `val`, изменяемое внутри лямбда-функции, - это копия исходного значения `val`. Спецификатор `mutable` позволяет изменять копию, но не исходную переменную.

Таким образом, при выводе значения `val` на экран будет выведено исходное значение, равное 0.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/fa3829ab-fa76-4cd8-96d8-874a883126de)


Рассмотрим второй пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/c74314fd-b224-41e5-a89e-a9c40fe147dd)

1. У нас есть 2 интовые переменные: `int val1 = 0, val2 = 0;`

2. Далее мы инициализируем лямбда-функцию и кладём её в переменную `func`.

3. Лямбда-функция захватывает `val1` по копии, а `val2` - по ссылке.

4. Добавляем `mutable`, так как хотим модифицировать копию `val1`.

5. `val++` увеличивает значение копии `val` на 1.

6. После этого `val2 = val1`.


Внутри функции `val1` будет равен 1, `val2` также будет равен 1.


7. После вызова функции:


`val1` будет равен 0 несмотря на модмификации внутри функции;


`val2` захвачен по ссылке, поэтому он будет равен 1. Мы изменили его внутри функции.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/1d745861-3bb5-497a-8759-23ed3fa85555)

## Можно рассматривать лямбду как класс с перегруженным оператором ()

Ранее, до появления лямбда-выражений, для сортировки сложных объектов можно было создать структуру (назовем ее Comparator), которая определит перегруженный оператор () для сравнения двух объектов типа exam_results. Внутри этой структуры можно было объявить необходимые переменные и определить тело оператора для сравнения.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/bf367393-6c3c-4b08-9a08-353baf885dfe)


С использованием лямбда-выражений, вы можете достичь того же результата более компактным образом. 

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/0bd9e8fc-c65a-46cf-99c5-23e8f008110d)


Обратите внимание, что круглые скобки при объявлении лямбда-выражения могут быть опущены, если оно не принимает аргументов.
