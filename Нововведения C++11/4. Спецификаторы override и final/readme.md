# Спецификатор override

Давайте вспомним, какая функция называется виртуальной.

Виртуальная функция — это функция, которая может быть переопределена в классах-наследниках. Виртуальные функции используются для динамического связывания во время выполнения программы, что позволяет классу-наследнику определять свое поведение при вызове функции. 

Для определения виртуальной функции используется ключевое слово `virtual` в объявлении функции и базовом классе, а также `override` в наследнике.

Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/d0e18521-7d72-4dcf-b0a1-5625c88e5d95)

В данном коде создаются два класса: `base` (базовый класс) и `derived` (производный класс), который наследуется от базового класса.

В базовом классе определена виртуальная функция `some_func`, которая принимает один аргумент типа `int` и выводит его значение с сообщением `in base class`.

В производном классе определена функция `some_func`, которая принимает один аргумент типа `double` и выводит его значение с сообщением `in derived class`.

В функции `main` создается указатель `obj` типа `base`, который указывает на новый объект `derived`. Затем вызывается функция `some_func` через указатель `obj`. 

На экране появится "2 in base class". 

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/7d71cf61-40ab-416f-8c60-2e69f0a5a385)

Но, почему не "2 in derived class"?

Важное правило переопределения в C++ гласит, что при переопределении функции в производном классе, входные типы (аргументы) должны совпадать с входными типами (аргументами) виртуальной функции базового класса. В случае, если типы не совпадают, это может привести к непредсказуемому поведению программы.

В данном коде правило переопределения нарушено, так как функция `some_func` в классе `derived` принимает аргумент типа `double`, в то время как виртуальная функция `some_func` в классе `base` принимает аргумент типа `int`. 

На самом деле, в классе `derived` мы создали новую функцию (перепутав тип входного аргумента у `some_func`), а не переопределили функцию базового класса. 

`class derived : public base {`

`public:`


`void some_func(double val)`

В больших программах такие ошибки будет довольно сложно найти.

Решение: использовать спецификатор `override`. 
Когда вы пишете `override`, вы говорите, что эта функция уже есть в базовом классе, я её просто переопределяю. 
Но компилятор выдаст ошибку, так как данный метод не переопределяет ни одну виртуальную функцию из базового класса.

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/9c5052cf-7157-4c53-8f6f-8decf9fcabc5)

# Спецификатор final

Если вы хотите, чтобы ваш метод больше не переопределялся, добавьте спецификатор `final`:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/231c09b6-2a63-41fd-a7cc-2bd9b983f64e)

В данном коде определены три класса: `base`, `derived1` и `derived2`. 

В классе `derived1` используется спецификатор `final`, который запрещает дальнейшее переопределение функции `some_func` в производных классах. Таким образом, класс `derived2` не может переопределить функцию `some_func` из класса `derived1`.

Таким образом, при выполнении кода, появятся ошибки:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/cf78ad3a-5d41-41d8-a784-edf93884af10)

