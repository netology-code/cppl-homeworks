# Нововведения C++14

1. Обобщённые лямбда-функции
2. Инициализаторы лямбда захвата
3. Автоматический вывод типов для функций
4. Разделители разрядов

## 1. Обобщённые лямбда-функции

Это возможность использовать  `auto ` в лямбда-функции.

Рассмотрим лямбда-функцию, которая используется для сортировки контейнера, хранящего целые числа:   

 `[](int lhs, int rhs) { return lhs > rhs; } `

А если хотим добавить тоже самое, но для контейнера, хранящего вещественные числа. Придется добавить еще одну функцию, отличающуюся только входными типами.

 `[](double lhs, double rhs) { return lhs > rhs; } `

Дублирование кода - это плохо.

### Решение: 

Для того, чтобы написать лямбда-функцию, которая работает для всех элементов, можно:
- использовать шаблоны (о них узнаете позже)
- в качестве входного параметра написать  `auto `

 `[](auto lhs, auto rhs) { return lhs > rhs; } `

Код будет работать для всех типов данных, у которых определён оператор  `> ` (больше)

Таким образом, мы избежали дублирования кода.


## 2. Инициализаторы лямбда-захвата

Обычно при создании лямбда-выражения в C++ можно захватить переменные из текущего контекста, чтобы иметь к ним доступ внутри лямбда-функции. Однако, в некоторых случаях может потребоваться инициализировать захваченные переменные с определенными значениями. Здесь инициализаторы лямбда-захвата приходят на помощь.

Инициализаторы лямбда-захвата представляются списком инициализаторов в квадратных скобках  `[ ]` перед аргументами лямбда-функции. Каждый инициализатор указывает на переменную, которая должна быть захвачена, и ее начальное значение.

Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/7d3cf4c5-a16a-4934-b380-95b32d447544)


![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/9c8f2172-78a0-468f-85c6-b9e37a32bdf7)


Инициализаторы лямбда-захвата позволяют более гибко управлять захватываемыми переменными и их начальными значениями. Они могут быть полезными, когда нужно устанавливать определенные значения для переменных, которые будут использоваться внутри лямбда-функции.

Благодаря этой возможности, можно использовать захват с перемещением. Захват с перемещением в лямбда-выражениях позволяет перемещать ресурсы вместо их копирования или захвата по ссылке. Использование инициализаторов лямбда-захвата может облегчить захват с перемещением.

### Для захвата с перемещением в инициализаторах лямбда-захвата используется синтаксис std::move(). 

Рассмотрим пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/d9eb47e0-f576-4ed4-9da2-642028054b0e)


Таким образом, `tmp` является временным объектом типа `std::vector<int>`, который захватывается лямбда-функцией `func`. Это позволяет использовать `tmp` внутри лямбда-функции без копирования данных, а только с помощью перемещения.

## 3. Автоматический вывод типов для функций  

Стало возможным не писать возвращаемый тип функции. Мы можем написать `auto` и тип вычислится позже автоматически.


Рассмотрим первый пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/66dda198-914a-4004-b519-7fe9a5c3b2f5)


Рассмотрим второй пример:

![image](https://github.com/netology-code/cppl-homeworks/assets/147130852/2ba4acc1-992f-4476-b6f8-86048a51c0b4)


Итак:

- Возвращаемая переменная должна быть передана или создана ранее в коде. Мы должны иметь возможность определить её тип явно.
- Если есть несколько точек возврата, то возвращаемое значение должно иметь общий тип.
- Можно использовать рекурсию, но рекурсивный вызов должен выполняться после первого возврата функции.
- Использовать можно после определения, предварительного объявления недостаточно.

## 4. Разделители разрядов 

Можно использовать апостроф для разделения разрядов в числах
Это улучшает читаемость кода

`auto big_integer = 1'000'000'000;`

`auto floating_point = 0.00'021'395'74;`

`auto binary_literal = 0b00100'0110'0110;`

