# Нововведения C++14

1. Обобщённые лямбда-функции
2. Инициализаторы лямбда захвата
3. Автоматический вывод типов для функций
4. Разделители разрядов

## 1. Обобщённые лямбда-функции

Это возможность использовать  `auto ` в лямбда-функции.

### Рассмотрим лямбда-функцию, которая используется для сортировки контейнера, хранящего целые числа:   

 `[](int lhs, int rhs) { return lhs > rhs; } `

А если хотим добавить тоже самое, но для контейнера, хранящего вещественные числа. Придется добавить еще одну функцию, отличающуюся только входными типами.

 `[](double lhs, double rhs) { return lhs > rhs; } `

Дублирование кода - это плохо.

### Решение: 

Для того, чтобы написать лямбда-функцию, которая работает для всех элементов, можно:
- использовать шаблоны (о них узнаете позже)
- в качестве входного параметра написать  `auto `

 `[](auto lhs, auto rhs) { return lhs > rhs; } `

Код будет работать для всех типов данных, у которых определён оператор  `> ` (больше)

Таким образом, мы избежали дублирования кода.


## 2. Инициализаторы лямбда-захвата

Обычно при создании лямбда-выражения в C++ можно захватить переменные из текущего контекста, чтобы иметь к ним доступ внутри лямбда-функции. Однако, в некоторых случаях может потребоваться инициализировать захваченные переменные с определенными значениями. Вот где инициализаторы лямбда-захвата приходят на помощь.

Инициализаторы лямбда-захвата представляются списком инициализаторов в квадратных скобках  `[ ]` перед аргументами лямбда-функции. Каждый инициализатор указывает на переменную, которая должна быть захвачена, и ее начальное значение.

### Рассмотрим пример:

`auto value {0};`


`auto function = [value = 5] {return value;};` // вернёт 5


Инициализаторы лямбда-захвата позволяют более гибко управлять захватываемыми переменными и их начальными значениями. Они могут быть полезными, когда нужно устанавливать определенные значения для переменных, которые будут использоваться внутри лямбда-функции.

Благодаря этой возможности, можно использовать захват с перемещением. Захват с перемещением в лямбда-выражениях позволяет перемещать ресурсы вместо их копирования или захвата по ссылке. Использование инициализаторов лямбда-захвата может облегчить захват с перемещением.

Для захвата с перемещением в инициализаторах лямбда-захвата используется синтаксис `std::move()`. 

### Рассмотрим пример:

`auto tmp = std::vector<int>(100000, 0);`


`auto func = [val = std::move(tmp)]{ return val[0]; };`

Данный код создает объект `std::vector<int>` с именем `tmp`, содержащий 100000 элементов, все инициализированные значением 0. 

Затем создается лямбда-функция `func`, которая захватывает `tmp` с помощью перемещения (используя `std::move`). 

Лямбда-функция возвращает значение первого элемента вектора `tmp (val[0])`.

Таким образом, `tmp` является временным объектом типа `std::vector<int>`, который захватывается лямбда-функцией `func`. Это позволяет использовать `tmp` внутри лямбда-функции без копирования данных, а только с помощью перемещения.

## 3. Автоматический вывод типов для функций  

Стало возможным не писать возвращаемый тип функции. Мы можем написать `auto` и тип вычислится позже автоматически.


Рассмотрим первый пример:

`auto Correct(int i) {`

`if (i == 1)`
 
 `return i;` // в качестве типа возвращаемого значения выводится int
 
 `else`
 
   `return Correct(i - 1) + i;` // теперь можно вызывать
   
`}`

Рассмотрим второй пример:

`auto Wrong(int i) {`

`if(i != 1)`

`return Wrong(i - 1) + i;` // неподходящее место для рекурсии, нет предшествующего возврата

`else`

`return i;` // в качестве типа возвращаемого значения выводится int

`}`

Итак:

- Возвращаемая переменная должна быть передана или создана ранее в коде. Мы должны иметь возможность определить её тип явно.
- Если есть несколько точек возврата, то возвращаемое значение должно иметь общий тип.
- Можно использовать рекурсию, но рекурсивный вызов должен выполняться после первого возврата функции.
- Использовать можно после определения, предварительного объявления недостаточно.

## 4. Разделители разрядов 

Можно использовать апостроф для разделения разрядов в числах
Это улучшает читаемость кода

`auto big_integer = 1'000'000'000;`

`auto floating_point = 0.00'021'395'74;`

`auto binary_literal = 0b00100'0110'0110;`

